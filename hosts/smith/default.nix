{
  lib,
  persistenceCommon,
  modulesPath,
  pkgs,
  config,
  trusted-ssh-keys,
  phps,
  ...
}:
{
  imports = [
    (modulesPath + "/profiles/qemu-guest.nix")
    # ./docker.nix
  ];

  boot.loader.grub.configurationLimit = 5;

  networking.hostName = "smith";
  networking.domain = "comicslate.org";
  networking.hosts = {
    "2a01:4f8:c010:d56::6" = [ "ghcr.io" ]; # https://danwin1210.de/github-ipv6-proxy.php
  };

  services.qemuGuest.enable = true;
  # workaround because the console defaults to serial
  boot.kernelParams = [ "console=tty" ];
  # initialize the display early to get a complete log
  boot.initrd.kernelModules = [ "virtio_gpu" ];

  sops.secrets.root-password = {
    sopsFile = secrets/root-password.bin;
    format = "binary";
    neededForUsers = true;
  };
  users.users.root.hashedPasswordFile = config.sops.secrets.root-password.path;

  services.openssh = {
    enable = true;
    # TODO: enable firewall and add firewall rule here.
    hostKeys = [
      # Don't need RSA.
      {
        path = "/etc/ssh/ssh_host_ed25519_key";
        type = "ed25519";
      }
    ];
  };

  users.users.root.openssh.authorizedKeys.keys = trusted-ssh-keys;
  networking.hostId = "474ffba4";

  systemd.network.enable = true;
  networking.useDHCP = false;
  networking.dhcpcd.enable = false;

  systemd.network.networks."20-ether-static" = {
    matchConfig.Type = "ether";
    networkConfig = {
      # - fetch GitHub (nixpkgs)
      # - fetch ghcr.io (RSS bot)
      # - fetch RSS feeds (RSS bot)
      # - connect to Discord (RSS bot)
      DHCP = "ipv4";
      Address = [ "2a01:4f9:c010:dff6::2/64" ];
    };
    routes = [
      { Gateway = "fe80::1"; }
    ];
  };

  # VM limitations:
  # 1. IPv4 required for GitHub access (wtf lol?). You can remove
  #    this paid address once nixos-rebuild works remotely.
  # 2. disko-install is copying files into /nix (overlayfs on iso)
  #    first, running out of 2GB RAM, so we use nixos-install directly.
  #
  # Installation:
  # 1. Mount NixOS ISO
  # 2. sudo passwd
  # 3. ip addr add pref::2/64 dev enp1s0 &&
  #    ip ro add default via fe80::1 dev enp1s0
  # 4. ssh-copy-id
  # 5. sudo passwd -l root
  # 6. rm -rf comicslate/{result,*.qcow2,.direnv}
  #    scp -r comicslate root@smith.comicslate.org
  # 7. nix --extra-experimental-features 'nix-command flakes' \
  #      run nixpkgs#disko -- \
  #        --yes-wipe-all-disks \
  #        --flake ~/comicslate#smith \
  #        --mode destroy,format,mount
  # 8. cd /mnt && nixos-install --flake ~/comicslate#smith
  # 9. reboot
  disko.devices = {
    disk = {
      root = {
        device = "/dev/sda";
        type = "disk";
        content = {
          # x86 Hetzner VMs only support legacy (non-EFI) boot.
          # Assuming 20GB+ disk.
          # ZFS doesn't make sense in single-disk, RAM-constrained VM env.
          type = "gpt";
          partitions = {
            boot = {
              size = "8M";
              type = "EF02"; # for grub MBR
            };
            ESP = {
              size = "512M";
              type = "EF00";
              content = {
                type = "filesystem";
                format = "vfat";
                mountpoint = "/boot";
                mountOptions = [ "umask=0077" ];
              };
            };
            swap = {
              size = "8G";
              content = {
                type = "swap";
                discardPolicy = "once";
              };
            };
            persistence = {
              size = "1G";
              content = {
                type = "filesystem";
                format = "ext4";
                mountpoint = "/persistent";
                mountOptions = [ "noatime" ];
              };
            };
            nix = {
              size = "100%";
              content = {
                type = "filesystem";
                format = "ext4";
                mountpoint = "/nix";
                mountOptions = [ "noatime" ];
              };
            };
          };
        };
      };
    };
    nodev = {
      # from https://github.com/nix-community/disko/issues/1089
      "/" = {
        device = "none";
        fsType = "tmpfs";
        mountpoint = "/";
        mountOptions = [
          "defaults"
          "size=2G" # out of 4GB RAM
          "mode=755" # only root can write to those files
        ];
      };
    };
  };

  environment.systemPackages = with pkgs; [
    htop
    cloudflared
    tcpdump
    ncdu
  ];

  sops.secrets.cloudflare-tunnel-comicslate = {
    # This is the file generated by "cloudflared tunnel create comicslate".
    sopsFile = secrets/cloudflare-tunnel-comicslate.json.bin;
    format = "binary";
  };
  sops.secrets."cloudflare-tunnel-cert" = {
    # This is the cert.pem obtained from "cloudflared tunnel login". It is
    # required to declaratively set up the tunnel (below), and it does have
    # write access to tunnels API.
    sopsFile = secrets/cloudflare-tunnel-cert.pem;
    # Place the file for "cloudflared" tool to find, if needed to be used from
    # command line (e.g. "cloudflared tunnel list").
    path = "/root/.cloudflared/cert.pem";
    format = "binary";
  };

  fileSystems."/var/www/new" = {
    device = "/dev/disk/by-id/scsi-0HC_Volume_103973620";
    fsType = "ext4";
    options = [
      "nofail"
      "noatime"
    ];
  };

  services.cloudflared = {
    enable = true;
    certificateFile = config.sops.secrets."cloudflare-tunnel-cert".path;
    tunnels = {
      "comicslate" = {
        credentialsFile = config.sops.secrets.cloudflare-tunnel-comicslate.path;
        ingress = {
          # Remember to create a proxied CNAME to "<tunnelid>.cfargotunnel.com",
          # e.g. automatically using
          # $ cloudflared tunnel route dns <tunnel-name> <dns-record>
          # i.e.
          # $ cloudflared tunnel route dns comicslate web2.comicslate.org
          "test.comicslate.org" = "http://localhost:80";
          "osp.dget.cc" = "http://localhost:80";

          # Create an Application for browser based access without installing
          # "cloudflared" on the client.
          "smith-ssh.comicslate.org" = "ssh://localhost:22";
          # TODO: smith.comicslate.org, and use IP address for emergency
          # reachability only.
          # This is not working at all, neither web nor command line. Why?
          # Check out https://developers.cloudflare.com/cloudflare-one/tutorials/gitlab/
        };
        default = "http_status:404";
        # TODO for QUIC:
        # sysctl -w net.core.rmem_max=7500000
        # sysctl -w net.core.wmem_max=7500000
      };
    };
  };

  # TODO: https://github.com/NixOS/nixpkgs/pull/448934
  systemd.services.cloudflared-tunnel-comicslate.environment.TUNNEL_EDGE_IP_VERSION = "6";

  services.openssh.settings.Macs = lib.mkAfter [
    # Current defaults:
    "hmac-sha2-512-etm@openssh.com"
    "hmac-sha2-256-etm@openssh.com"
    "umac-128-etm@openssh.com"
    # Added for cloudflare SSH browser rendering:
    "hmac-sha2-256"
  ];
  services.openssh.extraConfig = ''
    Match Address 127.0.0.1
      # Enable password authentication over cloudflared tunnel, which is already
      # secured by Cloudflare login.
      PasswordAuthentication yes
  '';

  fileSystems.${persistenceCommon}.neededForBoot = true;
  environment.persistence.${persistenceCommon} = {
    # https://nixos.org/manual/nixos/stable/#sec-nixos-state
    directories = [
      "/var/lib/nixos" # auto-generated UID and GID maps
      "/var/lib/systemd" # timers, random seed, clock sync etc
      "/var/lib/docker" # rss bot
      "/var/www" # TODO: remove!
    ];
    files = [
      "/etc/machine-id"
      "/etc/ssh/ssh_host_ed25519_key"
    ];
  };

  services.httpd = {
    enable = true;
    enablePHP = true;
    phpPackage = phps.php74;
    phpOptions = ''
      ; Doku relies on filesystem lookup a lot, this cache is handy.
      realpath_cache_size = 40M
      ; There's also a limit in CloudFlare, up to 100MB on free plan.
      upload_max_filesize = 15M
      post_max_size = 15M
      ; Some processes can grow really large.
      memory_limit = 1G
      ; sendmail command line working with nullmailer
      sendmail_path = /usr/sbin/sendmail -t -i
    '';
    virtualHosts = {
      "test.comicslate.org" = {
        documentRoot = "/var/www/new/comicslate.org";
        extraConfig = ''
          <Directory /var/www/new/comicslate.org>
            Options FollowSymLinks MultiViews
            AllowOverride All
          </Directory>
        '';
      };
      "osp.dget.cc" = {
        documentRoot = "/var/www/osp.dget.cc";
      };
    };
  };

  # Doesn't matter with impermanence, and better to know that on
  # each deploy rather than reboot.
  users.mutableUsers = false;

  system.stateVersion = "25.11";
}
